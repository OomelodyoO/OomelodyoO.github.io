<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java-thread]]></title>
    <url>%2F2019%2F05%2F29%2Fjava-thread%2F</url>
    <content type="text"><![CDATA[1.背景线程安全大多数时候很重要。 2.Thread线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 (1)Thread 五种状态新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 (2)Thread 常用方法 方法名称 类型 描述 public Thread(Runnable target) 构造 接收Runnable接口子类对象，实例化Thread对象 public Thread(Runnable target,String name) 构造 接收Runnable接口子类对象，实例化Thread对象，并设置线程名称 public Thread(String name) 构造 实例化Thread对象，并设置线程名称 public static Thread currentThread() 普通 返回目前正在运行的线程 public final String getName() 普通 返回线程名称 public final int getPriority() 普通 返回线程的优先级 public boolean isInterrupted() 普通 判断目前线程是否被中断 public final boolean isAlive() 普通 判断线程是否在活动 public final void join() throws Interrupted Exception 普通 等待线程死亡 public final synchronized void join(long millis) throws InterruptedException 普通 等待millis毫秒后，线程死亡 public void run() 普通 执行线程 public final void setName(String Name) 普通 设置线程名称 public final void setPriority(int newPriority) 普通 设置线程优先级 public static void sleep(long millis) throws InterruptedExeption 普通 使目前正在执行的线程休眠millis毫秒 public void start() 普通 开始执行线程 public String toString() 普通 返回代表线程的字符串 public static void yield() 普通 将目前正在执行的线程暂停，允许其他线程执行 public final void setDaemon(boolean on) 普通 将一个线程设置成后台运行 (3)Wait 方法wait()方法是Object类里的方法，当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁），其他线程可以访问。 wait()使用notify或者notifyAll或者指定睡眠时间来唤醒当前等待池中的线程。 wait()必须放在synchronized block中，否则会在program runtime时扔出 ”java.lang.IllegalMonitorStateException“ 异常。 sleep()和wait()方法的最大区别是： sleep()睡眠时，保持对象锁，仍然占有该锁 wait()睡眠时，释放对象锁。 wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。 3.代码12345678910111213141516171819public class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; if (!this.isInterrupted()) &#123; Thread.currentThread().sleep(50); System.out.println("线程" + getName() + ":" + i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617public class ThreadB extends Thread &#123; public ThreadB(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.currentThread().sleep(100); System.out.println("线程" + getName() + ":" + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Application &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadA threadA = new ThreadA("A"); ThreadB threadB = new ThreadB("B");// testNormal(threadA, threadB);// testWait(threadA, threadB);// testJoin(threadA, threadB); testInterrupt(threadA, threadB); for (int i = 0; i &lt; 10; i++) &#123; System.out.println("主线程:" + i); &#125; &#125; public static void testNormal(ThreadA threadA, ThreadB threadB) &#123; System.out.println("======普通线程启动======"); threadA.start(); threadB.start(); &#125; public static void testWait(ThreadA threadA, ThreadB threadB) throws InterruptedException &#123; System.out.println("======wait 测试======"); threadA.start(); synchronized (threadA) &#123; threadA.wait(); &#125; threadB.start(); synchronized (threadA) &#123; threadA.notify(); &#125; &#125; public static void testJoin(ThreadA threadA, ThreadB threadB) throws InterruptedException &#123; System.out.println("======join 测试======"); threadA.start(); threadA.join(); threadB.start(); &#125; public static void testInterrupt(ThreadA threadA, ThreadB threadB) throws InterruptedException &#123; System.out.println("======interrupt 测试======"); threadA.start(); threadA.interrupt(); threadB.start(); &#125;&#125; 4.总结CRUD谁都会，为了写出优秀的代码，必须静下心来学习。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Jvm]]></title>
    <url>%2F2019%2F05%2F27%2FJava%20Jvm%2F</url>
    <content type="text"><![CDATA[1.背景为了更好的使用java进行编程 2.JVM PC程序计数器(线程私有) 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 虚拟机栈(线程私有) 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表： 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 操作数栈： Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指－操作数栈。 动态连接： 在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。 本地方法栈(线程私有) 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 堆（Heap-线程共享） 是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。 方法区/永久代（线程共享） 即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。 参数名称 含义 默认值 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) -Xmn 年轻代大小(1.4or lator) -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:SurvivorRatio Eden区与Survivor区的大小比值 3.总结以上可知由于线程有共享的部分，会造成线程不安全的情况。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济名词]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%BB%8F%E6%B5%8E%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[概念GDP=国内生产总值一个国家(或地区)所有常驻单位，在一定时期内，生产的全部最终产品和服务价值的总和，常被认为是衡量国家(或地区)经济状况的指标。 CPI=居民消费价格指数（consumer price index）居民消费价格指数，是一个反映居民家庭一般所购买的消费品和服务项目价格水平变动情况的宏观经济指标。它是在特定时段内度量一组代表性消费商品及服务项目的价格水平随时间而变动的相对数，是用来反映居民家庭购买消费商品及服务的价格水平的变动情况。 PPI=生产价格指数（Producer Price Index）衡量工业企业产品出厂价格变动趋势和变动程度的指数，是反映某一时期生产领域价格变动情况的重要经济指标，也是制定有关经济政策和国民经济核算的重要依据。生产者物价指数（Producer Price Index, PPI）与CPI不同，主要的目的是衡量企业购买的一篮子物品和劳务的总费用。由于企业最终要把它们的费用以更高的消费价格的形式转移给消费者，所以，通常认为生产物价指数的变动对预测消费物价指数的变动是有用的。 PMI=采购经理指数（Purchasing Managers’ Index）通过对采购经理的月度调查汇总出来的指数，反映了经济的变化趋势。PMI是一套月度发布的、综合性的经济监测指标体系，分为制造业PMI、服务业PMI，也有一些国家建立了建筑业PMI。PMI指数50为荣枯分水线。 M0=流通中现金银行体系以外各个单位的库存现金和居民的手持现金之和。 M1=狭义货币供应量M0加上单位在银行的活期存款。 M2=广义货币供应量M1加上单位在银行的定期存款和城乡居民个人在银行的各项储蓄存款以及证券客户保证金。M2与M1的差额，即单位的定期存款和个人的储蓄存款之和，通常称作准货币。 M0=流通中现金M1=M0+单位活期存款M2=M1+单位定期存款+个人的储蓄存款+证券公司的客户保证金M3=M2+具有高流动性的证券和其它资产]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
        <tag>经济</tag>
        <tag>概念</tag>
        <tag>名词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI、VC、PE、IPO]]></title>
    <url>%2F2018%2F12%2F19%2FAI%E3%80%81VC%E3%80%81PE%E3%80%81IPO%2F</url>
    <content type="text"><![CDATA[概念天使投资(AI)：指具有一定净财富的人士，对具有巨大发展潜力的高风险的初创企业进行早期的直接投资。 风险投资（VC)：由一群具有科技及财务相关知识与经验的人所组合而成的，经由直接投资获取投资公司股权的方式，提供资金给需要资金者（被投资公司）。 私募基金(PE)：是指以非公开方式向特定投资者募集资金并以证券为投资对象的证券投资基金。私募基金是以大众传播以外的手段招募,发起人集合非公众性多元主体的资金设立投资基金，进行证券投资。 首次公开募股(IPO)：是指一家企业或公司 （股份有限公司）第一次将它的股份向公众出售。 顺序AI–&gt;VC–&gt;PE–&gt;IPO 天使投资–&gt;A轮–&gt;B轮–&gt;C轮–&gt;…–&gt;IPO]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基金相关概念]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%9F%BA%E9%87%91%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[概念1.基金： 广义：基金是指为了某种目的而设立的具有一定数量的资金。例如，信托投资基金、公积金、保险基金、退休基金，各种基金会的基金。 狭义：人们平常所说的基金主要是指证券投资基金。 2.债券：债券是政府、企业、银行等债务人为筹集资金,按照法定程序发行并向债权人承诺于指定日期还本付息的有价证券。 3.股票：股票（stock）是股份公司发行的所有权凭证，是股份公司为筹集资金而发行给各个股东作为持股凭证并借以取得股息和红利的一种有价证券。 4.认购：一般只有新基金才有的名词。 5.申购：募集期之外的购买该基金的行为的称呼。 6.赎回：就是将手中的基金卖掉，换回现金。 7.基金份额：是指基金发起人向投资者公开发行的，表示持有人按其所持份额对基金财产享有收益分配权、清算后剩余财产取得权和其他相关权利，并承担相应义务的凭证。 8.基金净值：是指当前的基金总净资产除以基金总份额。其计算公式为：基金单位净值=总净资产/基金份额。 分类1.开发式与封闭式 总份额是否固定 是否能与基金公司买卖 开发式 不固定 能 封闭式 固定 不能 2.股票型、债券型、混合型 股票型基金：是指股票型基金的股票仓位不能低于80%。 债券型基金：基金资产80%以上投资于债券的为债券基金。 混合型基金：除股票型基金，债券型基金以为的属于混合型基金。 3.指数型基金 就是以指数成分股为投资对象的基金，力求取得与指数大致相同的投资收益率。 4.货币基金 全称是货币市场基金，它只投资于定存、一年以下的短期债券等风险极低的品种。 5.保本基金 就是在一定期间内，对所投资的本金提供一定比例的保证保本的基金。 6.成长型、收入型、平衡型 成长型基金：注重资本利得，追求公司的资本增值，主要投资有较大升值空间的股票。 收入型基金：注重红利，追求当前收入为目标，主要投资分红多的股票、债券。 平衡型基金：介于两者之间。 7.公募基金和私募基金 公募基金：是公开募集资金，公开销售的基金。 私募基金：是私下募集基金， 不公开销售的基金。 类别 针对对象 募集方式 信息披露 投资限制 管理费 公募 社会大众 公开发行 公开 严格限制 按比例收取 私募 特定对象 私下募集 保密 协议约定 按业绩收取]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[足彩问题]]></title>
    <url>%2F2018%2F12%2F12%2F%E8%B6%B3%E5%BD%A9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据1)A，B两支球队2)博彩公司赔率 公司 A胜 平 B胜 C1 1.40 4.57 6.5 C2 1.31 5.75 9.55 C3 1.32 5.65 11.5 策略表中数据为获得100元，所要花费的金额 公司 A胜 平 B胜 总计 C1 71.5 21.9 15.4 108.8 C2 76.4 17.4 10.5 104.3 C3 75.76 17.7 8.7 102.16 最小值 71.5 17.4 8.7 97.6 总结以上这些，博彩公司肯定十分清楚。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凯利公式]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%87%AF%E5%88%A9%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[问题某项投资： 数据 F f p q b 概率 拥有资本总值 应投资本比值 获胜概率 失败概率(1 - p) 赔率 那么应不应该投资？应该如何投资？ 推导第k+1次投资结果成功投资：$F_{k+1} = F_k(1+bf)$失败投资：$F_{k+1} = F_k(1-f)$ 第n次投资结果$F_n = F (1+bf)^{np}(1-f)^{n(1-p)}$ 取对数： $\sqrt[n]{F_n \over F} = (1+bf)^{p}(1-f)^{(1-p)}$ $\ln F_{(f)} = \ln(1+bf)^{p}(1-f)^{(1-p)}$ $\ln F_{(f)} = \ln(1+bf)^{p} + \ln(1-f)^{(1-p)}$ $\ln F_{(f)} = p\ln(1+bf)+(1-p)\ln(1-f)$ 求导： ${d\ln F_{(f)} \over df } = p{1 \over (1+bf)}(1+bf)^{‘} + (1-p){1 \over (1-f)}(1-f)^{‘}$ ${d\ln F_{(f)} \over df } = {pb \over (1+bf)} + {(1-p)(-1) \over (1-f)}$ ${d\ln F_{(f)} \over df } = {(pb + p -1) - bf \over (1+bf)(1-f)}$ 因为$\ln F_{(f)}$为增函数，所以导数如果等于0，可以求取最大值，即每次投资收益最大值。 公式$$f = {pb - (1 - p) \over b}$$f &gt; 0 按比例投资f &lt; 0 不投资 结论理论永远是理论，不要和现实混为一谈。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数定律]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[定义在数学与统计学中，大数定律又称大数法则、大数律，是描述相当多次数重复实验的结果的定律。根据这个定律知道，样本数量越多，则其算术平均值就越趋近期望值。 举例1)抛掷一颗均匀的6面的骰子，六面出现概率为 数据 1 2 3 4 5 6 概率 1/6 1/6 1/6 1/6 1/6 1/6 数学期望 = 1 × (1/6) + 2 × (1/6) + 3 × (1/6) + 4 × (1/6) + 5 × (1/6) + 6 × (1/6) 数学期望 = 3.5 2)使用程序模拟投掷过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Application &#123; public static void main(String[] args) &#123; int count = 100 * 10000; int oneCount = 0; int twoCount = 0; int threeCount = 0; int fourCount = 0; int fiveCount = 0; int sixCount = 0; for (int i = 1; i &lt;= count; i++) &#123; int ran = (int) (Math.random() * 6) + 1; switch (ran) &#123; case 1: oneCount = oneCount + 1; break; case 2: twoCount = twoCount + 1; break; case 3: threeCount = threeCount + 1; break; case 4: fourCount = fourCount + 1; break; case 5: fiveCount = fiveCount + 1; break; case 6: sixCount = sixCount + 1; break; &#125; if (i == 100 || i == 10000 || i == 1000000) &#123; System.out.println(&quot;第&quot; + i + &quot;次统计：&quot;); System.out.println(&quot;1\t2\t3\t4\t5\t6&quot;); System.out.print(oneCount + &quot;\t&quot;); System.out.print(twoCount + &quot;\t&quot;); System.out.print(threeCount + &quot;\t&quot;); System.out.print(fourCount + &quot;\t&quot;); System.out.print(fiveCount + &quot;\t&quot;); System.out.println(sixCount); System.out.print(new BigDecimal(oneCount).divide(new BigDecimal(i)) + &quot;\t&quot;); System.out.print(new BigDecimal(twoCount).divide(new BigDecimal(i)) + &quot;\t&quot;); System.out.print(new BigDecimal(threeCount).divide(new BigDecimal(i)) + &quot;\t&quot;); System.out.print(new BigDecimal(fourCount).divide(new BigDecimal(i)) + &quot;\t&quot;); System.out.print(new BigDecimal(fiveCount).divide(new BigDecimal(i)) + &quot;\t&quot;); System.out.println(new BigDecimal(sixCount).divide(new BigDecimal(i))); &#125; &#125; &#125;&#125; 3)统计结果第100次统计： 数据 1 2 3 4 5 6 出现次数 17 15 16 19 21 12 出现概率 0.17 0.15 0.16 0.19 0.21 0.12 总数为：348 算术平均数为：3.48 第10000次统计： 数据 1 2 3 4 5 6 出现次数 1724 1638 1639 1636 1664 1699 出现概率 0.1724 0.1638 0.1639 0.1636 0.1664 0.1699 总数为：34975 算术平均数为：3.4975 第1000000次统计： 数据 1 2 3 4 5 6 出现次数 167149 166751 166553 166521 166688 166338 出现概率 0.167149 0.166751 0.166553 0.166521 0.166688 0.166338 总数为：3497862 算术平均数为：3.497862 结论随着投掷次数的不断增多，算术平均数无限接近于期望值]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>定律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8]]></title>
    <url>%2F2018%2F12%2F04%2FJava%208%2F</url>
    <content type="text"><![CDATA[1.背景按照 Java 的发布计划，Java 12 将于2019年 3 月推出，本人现在还在使用Java 8，这本身没有什么问题，但“惭愧”的是目前不会使用8的新特性。 “这段代码中，使用了Java 8 的LAMBDA表达式”。 “一会让你见识见识Java 8 的STREAM有多好用”。 每当听到或看到，类似以上内容的话语或文字的时候，发出感慨者那种优于其它人的自豪感，让我更加的“惭愧”。 2.代码LAMBDA1234567891011121314151617181920212223public class test &#123; public static void main(String[] args) &#123; // 不用LAMBDA MathOperation mathOperation = new MathOperation() &#123; @Override public int operation(int a, int b) &#123; return a + b; &#125; &#125;; System.out.println(new test().operate(100, 50, mathOperation)); // 用LAMBDA System.out.println(new test().operate(100, 50, (a, b) -&gt; a + b)); &#125; interface MathOperation &#123; int operation(int a, int b); &#125; private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operation(a, b); &#125;&#125; STREAM Set;List;Map;SortedSet;SortedMap;HashSet;TreeSet;ArrayList;LinkedList;Vector;Collections;Arrays;AbstractCollection以上这些类都有stream()方法，这就是传说中的STREAM。 filter 方法用于通过设置的条件过滤出元素。 sorted 方法用于对流进行排序。 map 方法用于映射每个元素到对应的结果。 123456789101112131415public class test &#123; public static void main(String[] args) &#123; List&lt;String&gt; rStrings; List&lt;String&gt; strings = Arrays.asList("a", "ab", "ac", "d", "e", "f", "ag"); System.out.println("stream filter:"); rStrings = strings.stream().filter(string -&gt; string.contains("a")).collect(Collectors.toList()); System.out.println(rStrings.toString()); System.out.println("stream sorted:"); rStrings = strings.stream().sorted().collect(Collectors.toList()); System.out.println(rStrings.toString()); System.out.println("stream map:"); rStrings = strings.stream().map(string -&gt; string + string).collect(Collectors.toList()); System.out.println(rStrings.toString()); &#125;&#125; Console123456stream filter:[a, ab, ac, ag]stream sorted:[a, ab, ac, ag, d, e, f]stream map:[aa, abab, acac, dd, ee, ff, agag] 3.总结代码变简洁了，可读性和调试变得不方便了。 4.名人名言有的人滥用形容词语和形容句子，以为堆砌得越多越漂亮；有的人不肯顺着一般人的表达习惯来写，以为不说些离奇别扭的话就不成其为文章；有的人搬弄一些俗滥的成语或者典故，以为不这样做不足以显示自己的高明。—叶圣陶 有真意，去粉饰，少做作，勿卖弄。—鲁迅]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步、同步、阻塞、非阻塞]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%BC%82%E6%AD%A5%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[事件：打电话订外卖，拨通老板电话，询问菜品，选菜。同步：老板说：”我看一下厨房，还有没菜，还能不能做！”，然后就去问了，等确认后告诉你结果。（可能一分钟，也可能好久好久）异步：老板说：”我去查一下，查好了电话告诉你！”，然后就挂电话了。（不返回结果）等确认后，给你打电话。 阻塞：你等待，不去做任何事情，一直等待结果。非阻塞：你不等待，先去做别的事情，偶尔检查一下老板有没有老板的消息。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>同步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F11%2F17%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、初始化仓库1234# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] 二、工作区–&gt;暂存区123456# 添加指定文件到暂存区git add [file1] [file2] ...# 添加当前目录的所有文件到暂存区git add .# 从暂存区删除到工作区git rm --cached &lt;file&gt;... 三、暂存区–&gt;仓库区1git commit -m &quot;message...&quot; 四、分支12345678910# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 删除分支git branch -d [branch-name] 五、远程同步123456789# remote为url地址，或者本地起到别名 branch为本地分支名# 为远程地址起名git remote add [&lt;options&gt;] &lt;name&gt; &lt;url&gt;# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 列出所有远程别名git remote -v 六、查看信息1234# 显示有变更的文件git status# 显示当前分支的版本历史git log]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学逻辑题]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%95%B0%E5%AD%A6%E9%80%BB%E8%BE%91%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.红眼睛和蓝眼睛一个岛上有100个人，其中有5个红眼睛，95个蓝眼睛。这个岛有三个奇怪的宗教规则。 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就必须在当天夜里自杀。 某天，有个旅行者到了这个岛上。由于不知道这里的规矩，所以他在和全岛人一起狂欢的时候，不留神就说了一句话：【你们这里有红眼睛的人。】假设这个岛上的人足够聪明，每个人都可以做出缜密的逻辑推理。请问这个岛上将会发生什么？]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Install ActiveMQ]]></title>
    <url>%2F2018%2F10%2F22%2FWindows%20Install%20ActiveMQ%2F</url>
    <content type="text"><![CDATA[1.下载地址ActiveMQ下载地址 2.解压安装使用解压工具对压缩包进行解压 3.单节点启动1.\bin\win64\activemq.bat 访问http://localhost:8161/admin用户名:admin密码:admin 4.集群启动 zookeeper集群启动 (Windows Install ZooKeeper) activemq.xml配置 (本文配置三台机器) Master/Slave配置node1123456789101112&lt;persistenceAdapter&gt; &lt;!-- &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt; --&gt; &lt;replicatedLevelDB directory=&quot;$&#123;activemq.data&#125;/leveldb&quot; replicas=&quot;3&quot; bind=&quot;tcp://0.0.0.0:62621&quot; zkAddress=&quot;localhost:2181,localhost:2182,localhost:2183&quot; hostname=&quot;localhost&quot; sync=&quot;local_disk&quot; zkPath=&quot;/activemq/leveldb-stores&quot; /&gt;&lt;/persistenceAdapter&gt; 1.\bin\win64\activemq.bat node2123456789101112&lt;persistenceAdapter&gt; &lt;!-- &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt; --&gt; &lt;replicatedLevelDB directory=&quot;$&#123;activemq.data&#125;/leveldb&quot; replicas=&quot;3&quot; bind=&quot;tcp://0.0.0.0:62622&quot; zkAddress=&quot;localhost:2181,localhost:2182,localhost:2183&quot; hostname=&quot;localhost&quot; sync=&quot;local_disk&quot; zkPath=&quot;/activemq/leveldb-stores&quot; /&gt;&lt;/persistenceAdapter&gt; 1.\bin\win64\activemq.bat node3123456789101112&lt;persistenceAdapter&gt; &lt;!-- &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt; --&gt; &lt;replicatedLevelDB directory=&quot;$&#123;activemq.data&#125;/leveldb&quot; replicas=&quot;3&quot; bind=&quot;tcp://0.0.0.0:62623&quot; zkAddress=&quot;localhost:2181,localhost:2182,localhost:2183&quot; hostname=&quot;localhost&quot; sync=&quot;local_disk&quot; zkPath=&quot;/activemq/leveldb-stores&quot; /&gt;&lt;/persistenceAdapter&gt; 1.\bin\win64\activemq.bat]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Install Kafka]]></title>
    <url>%2F2018%2F10%2F17%2FWindows%20Install%20Kafka%2F</url>
    <content type="text"><![CDATA[1.下载地址kafka下载地址 2.解压安装使用解压工具对压缩包进行解压 3.配置参数 配置参数 12345678910111213141516171819202122232425broker.id=0#listeners=PLAINTEXT://:9092#advertised.listeners=PLAINTEXT://your.host.name:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600# log存放位置log.dirs=F:\\kafka_2.12-2.0.0\\logsnum.partitions=1num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1#log.flush.interval.messages=10000#log.flush.interval.ms=1000log.retention.hours=168#log.retention.bytes=1073741824log.segment.bytes=1073741824log.retention.check.interval.ms=300000# 连接zookeeper集群地址zookeeper.connect=localhost:2181,localhost:2182,localhost:2183zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0 4.启动启动Server:1.\kafka-server-start.bat server.properties 创建topic1.\bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test3 查看topic1.\bin\windows\kafka-topics.bat --list --zookeeper localhost:2181 producer启动1.\bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test consumer启动1.\kafka_2.12-2.0.0\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning kafka源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Install ZooKeeper]]></title>
    <url>%2F2018%2F10%2F17%2FWindows%20Install%20ZooKeeper%2F</url>
    <content type="text"><![CDATA[笔者认为只要能在Windows下运行的项目，在MacOS、Linux出现问题的概率会很小，所以此次选择在Windows环境下安装运行zookeeper项目。 1.下载地址ZooKeeper下载地址 2.解压安装使用解压工具对压缩包进行解压 3.配置参数 进入conf文件夹 复制zoo_sample.cfg文件为zoo.cfg 配置参数 1234567891011121314151617# 服务器客户端心跳间隔（毫秒）tickTime=2000# 初始化连接忍受多少个tickTime时间间隔initLimit=10# leader与follower发送消息，请求应答时间，不能超过多少个tickTimesyncLimit=5# 数据存放位置dataDir=F:\\zookeeper-3.4.13\\data# 日志存放位置dataLogDir=F:\\zookeeper-3.4.13\\log# 开启端口号clientPort=2181# server.X=A:B:C X-代表服务器编号 A-代表ip B和C-代表端口，这个端口用来系统之间通信# 配置集群 需要在dataDir文件内增加myid文件，文件内容为相应服务器编号server.1=localhost:2888:3888server.2=localhost:2889:3889server.3=localhost:2890:3890 4.启动Server:1zkServer.cmd Client1zkCli.cmd 5.授权管理ZOOKEEPER权限分为: CREATE: 你可以创建子节点。 READ: 你可以获取节点数据以及当前节点的子节点列表。 WRITE: 你可以为节点设置数据。 DELETE: 你可以删除子节点。 ADMIN: 可以为节点设置权限。 CreateMode节点创建方式 PERSISTENT：客户端与zookeeper断开连接后，该节点依旧存在 PERSISTENT_SEQUENTIAL：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 EPHEMERAL：客户端与zookeeper断开连接后，该节点被删除 EPHEMERAL_SEQUENTIAL：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号 ZOOKEEPER命令:创建node1create /acl acl 查看节点列表1ls / 查看节点信息1get / 设置节点信息1set / info 删除节点1delete / 通过setAcl设置用户名和密码12setAcl path digest:username:base64(sha1(password)):crwdasetAcl /acl digest:zookeeper:4lvlzsipXVaEhXMd+2qMrLc0at8=:r 认证1addauth digest username:password zookeeper源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（三）JAVA NIO SELECTOR]]></title>
    <url>%2F2018%2F09%2F12%2F%EF%BC%88%E4%B8%89%EF%BC%89JAVA%20NIO%20SELECTOR%2F</url>
    <content type="text"><![CDATA[Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。SelectServer.java123456789101112131415161718192021222324252627282930313233343536373839public class SelectServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); serverSocketChannel.configureBlocking(false); Selector selector = Selector.open(); SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; int select = selector.select(); if (select &gt; 0) &#123; Iterator keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey next = (SelectionKey) keyIterator.next(); keyIterator.remove(); if (next.isAcceptable()) &#123; System.out.println(&quot;isAcceptable&quot;); SocketChannel channel = ((ServerSocketChannel) next.channel()).accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (next.isConnectable()) &#123; System.out.println(&quot;connect&quot;); &#125; else if (next.isReadable()) &#123; System.out.println(&quot;isReadable&quot;); SocketChannel socketChannel = (SocketChannel) next.channel(); ByteBuffer readByteBuffer = ByteBuffer.allocate(100); int read = socketChannel.read(readByteBuffer); System.out.println(new String(readByteBuffer.array(), 0, read)); socketChannel.register(selector, SelectionKey.OP_WRITE); socketChannel.write(readByteBuffer); &#125; else if (next.isWritable()) &#123; System.out.println(&quot;isWritable&quot;); SocketChannel socketChannel = (SocketChannel) next.channel(); socketChannel.register(selector, SelectionKey.OP_READ); &#125; &#125; &#125; &#125; &#125;&#125; NioChannelClient.java12345678910public class NioChannelClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999)); while (true) &#123; Scanner input = new Scanner(System.in); socketChannel.write(ByteBuffer.wrap(input.nextLine().getBytes())); &#125; &#125;&#125; Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）JAVA NIO CHANNEL]]></title>
    <url>%2F2018%2F09%2F11%2F%EF%BC%88%E4%BA%8C%EF%BC%89JAVA%20NIO%20CHANNEL%2F</url>
    <content type="text"><![CDATA[FileChannel 从文件中读写数据。FileChannelTest.java12345678910111213141516171819public class FileChannelTest &#123; public static void main(String[] args) throws IOException &#123; FileChannel inputFileChannel = new FileInputStream(&quot;file.text absolute path&quot;).getChannel(); ByteBuffer readBuffer = ByteBuffer.allocate(100); inputFileChannel.read(readBuffer); readBuffer.flip(); for (int i = 0; i &lt; readBuffer.limit(); i++) &#123; System.out.println((char) readBuffer.get()); &#125; FileChannel outputFileChannel = new FileOutputStream(&quot;file.text absolute path&quot;, true).getChannel(); ByteBuffer writeBuffer = ByteBuffer.wrap(&quot;TOM&quot;.getBytes()); outputFileChannel.write(writeBuffer); inputFileChannel.close(); outputFileChannel.close(); &#125;&#125; DatagramChannel 能通过UDP读写网络中的数据。DatagramChannelServer.java12345678910111213141516public class DatagramChannelServer &#123; public static void main(String[] args) throws IOException &#123; DatagramChannel channel = DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(9999)); ByteBuffer buf = ByteBuffer.allocate(48); while (true) &#123; channel.receive(buf); buf.flip(); for (int i = 0; i &lt; buf.limit(); i++) &#123; System.out.println((char) buf.get()); &#125; buf.clear(); &#125; &#125;&#125; DatagramChannelClient.java12345678public class DatagramChannelClient &#123; public static void main(String[] args) throws IOException &#123; DatagramChannel channel = DatagramChannel.open(); ByteBuffer buf = ByteBuffer.allocate(48); buf = buf.wrap(&quot;AA&quot;.getBytes()); channel.send(buf, new InetSocketAddress(&quot;localhost&quot;, 9999)); &#125;&#125; ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。SocketChannel 能通过TCP读写网络中的数据。NioChannelServer.java123456789101112131415161718public class NioChannelServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); ByteBuffer buf = ByteBuffer.allocate(48); while (true) &#123; SocketChannel channel = serverSocketChannel.accept(); while (true) &#123; channel.read(buf); buf.flip(); for (int i = 0; i &lt; buf.limit(); i++) &#123; System.out.println((char) buf.get()); &#125; buf.clear(); &#125; &#125; &#125;&#125; NioChannelClient.java12345678910public class NioChannelClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999)); while (true) &#123; Scanner input = new Scanner(System.in); socketChannel.write(ByteBuffer.wrap(input.nextLine().getBytes())); &#125; &#125;&#125; Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）JAVA NIO BUFFER]]></title>
    <url>%2F2018%2F09%2F10%2F%EF%BC%88%E4%B8%80%EF%BC%89JAVA%20NIO%20BUFFER%2F</url>
    <content type="text"><![CDATA[1.变量：capacity： 指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。position： 下一次读取或写入的位置。（每次调用get put方法+1）limit：指定还有多少数据需要取出，或者还有多少空间可以放入数据。（每次调用get put方法时候，通过position与limit对比） 2.方法：get：position + 1put：position + 1flip：limit = position position = 0 mark = -1clear：limit = capacity position = 0 mark = -1mark： mark = positionreset：position = m;duplicate：浅拷贝（每个缓存区的上界、容量、位置等属性是各自独立的） 3.代码BufferTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class BufferTest &#123; public static void main(String[] args) &#123; IntBuffer buff = IntBuffer.allocate(10); buff.get(); buff.put(1); buff.get(); buff.put(2); buff.get(); buff.put(3); buff.mark(); buff.get(); buff.put(4); buff.get(); buff.put(5); System.out.println(&quot; ========== init ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(); buff.reset(); System.out.println(&quot; ========== mark reset ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(); buff.flip(); System.out.println(&quot; ========== flip ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(buff.get() + &quot;\t&quot;); &#125; System.out.println(); System.out.println(); buff.clear(); System.out.println(&quot; ========== clear ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(buff.get() + &quot;\t&quot;); &#125; System.out.println(); System.out.println(); //重新数据初始化 System.out.println(&quot; ========== duplicate ========== &quot;); buff.clear(); IntBuffer copyIntBuffer = buff.duplicate(); buff.get(); buff.put(2); System.out.println(&quot; ========== buff duplicate ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(buff); System.out.println(&quot; ========== copyIntBuffer duplicate ========== &quot;); System.out.println(&quot;capacity:\t&quot; + copyIntBuffer.capacity()); System.out.println(&quot;limit:\t&quot; + copyIntBuffer.limit()); System.out.println(&quot;position:\t&quot; + copyIntBuffer.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(copyIntBuffer.get() + &quot;\t&quot;); &#125; System.out.println(); &#125;&#125; 4.Console123456789101112131415161718192021222324252627282930313233 ========== init ========== capacity: 10limit: 10position: 10 ========== mark reset ========== capacity: 10limit: 10position: 6 ========== flip ========== capacity: 10limit: 6position: 00 1 0 2 0 3 ========== clear ========== capacity: 10limit: 10position: 00 1 0 2 0 3 0 4 0 5 ========== duplicate ========== ========== buff duplicate ========== capacity: 10limit: 10position: 2java.nio.HeapIntBuffer[pos=2 lim=10 cap=10] ========== copyIntBuffer duplicate ========== capacity: 10limit: 10position: 00 2 0 2 0 3 0 4 0 5 Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(TOPICS模式)]]></title>
    <url>%2F2018%2F09%2F09%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-TOPICS%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;item.broadcast&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132333435public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_topic_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.broadcast&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.a&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 1234567891011121314151617181920212223242526272829303132333435public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_topic_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.broadcast&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.b&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(ROUTING模式)]]></title>
    <url>%2F2018%2F09%2F08%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-ROUTING%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;insert&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132333435public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_direct_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_direct_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(P/S模式)]]></title>
    <url>%2F2018%2F09%2F07%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-P-S%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 12345678910111213141516171819202122232425262728293031323334public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_ps_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_ps_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(WORK模式)]]></title>
    <url>%2F2018%2F09%2F06%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-WORK%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 1234567891011121314151617181920212223242526272829public class Send &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); for (int i = 0; i &lt; 50; i++) &#123; String message = &quot;message:\t&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(message); try &#123; Thread.sleep(i * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.basicQos(1); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.basicQos(1); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket]]></title>
    <url>%2F2018%2F09%2F06%2FJava%20Socket%2F</url>
    <content type="text"><![CDATA[Server.java12345678910111213141516171819202122232425public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(8081); while (true) &#123; Socket socket = serverSocket.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String str = &quot;&quot;; while ((str = bufferedReader.readLine()) != null) &#123; if (str.equals(&quot;1&quot;)) &#123; Thread.sleep(5 * 1000); &#125; System.out.println(str); &#125; &#125; catch (IOException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; Client.java12345678910111213public class Client &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;localhost&quot;, 8081); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in, &quot;UTF-8&quot;)); while (true) &#123; String str = bufferedReader.readLine(); bufferedWriter.write(str); bufferedWriter.write(&quot;\n&quot;); bufferedWriter.flush(); &#125; &#125;&#125; Java Socket源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(SIMPLE模式)]]></title>
    <url>%2F2018%2F09%2F05%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-SIMPLE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718192021public class Send &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); String message = &quot;message&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 12345678910111213141516171819202122232425public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置ssl证书]]></title>
    <url>%2F2018%2F09%2F04%2FNginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1234567891011server &#123; listen 80; listen 443 ssl; server_name localhost; ssl_certificate /SSLPATH/zhang.crt; ssl_certificate_key /SSLPATH/zhang.key; location / &#123; # TOMCAT proxy_pass http://localhost:5566; &#125;&#125; OPENSSL 自签证书]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openssl 自签证书]]></title>
    <url>%2F2018%2F09%2F04%2FOpenssl%20%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1.（.key）文件通常指私钥。 openssl genrsa -des3 -out zhang.key 1024 2.（.csr）文件csr 是Certificate Signing Request的缩写，即证书签名请求，这不是证书，可以简单理解成公钥，生成证书时要把这个提交给权威的证书颁发机构。 openssl req -new -key zhang.key -out zhang.csr 3.（.crt）crt 即 certificate的缩写，即证书。 openssl x509 -req -days 365 -in zhang.csr -signkey zhang.key -out zhang.crt]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https]]></title>
    <url>%2F2018%2F09%2F03%2FHttps%2F</url>
    <content type="text"><![CDATA[1.HTTP 应用层协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 2.SSL/TLS 会话层协议SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。 3.对称加密非对称加密对称加密技术:“加密”和“解密”密钥相同 非对称加密技术“加密”和“解密”密钥不相同 4.TPC/IP 传输层协议这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 HTTPS=HTTP+SSL/TLS]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http Session]]></title>
    <url>%2F2018%2F08%2F31%2FHttp%20Session%2F</url>
    <content type="text"><![CDATA[1.Cookie简介Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。 目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。 持续的 Cookie 则保存在用户的 Cookie 文件中，下一次用户返回时，仍然可以对它进行调用。在 Cookie 文件中保存 Cookie，有些用户担心 Cookie 中的用户信息被一些别有用心的人窃取，而造成一定的损害。其实，网站以外的用户无法跨过网站来获得 Cookie 信息。如果因为这种担心而屏蔽 Cookie，肯定会因此拒绝访问许多站点页面。因为，当今有许多 Web 站点开发人员使用 Cookie 技术，例如 Session 对象的使用就离不开 Cookie 的支持。 2.Session简介Session 是 用于保持状态的基于 Web服务器的方法。Session 允许通过将对象存储在 Web服务器的内存中在整个用户会话过程中保持任何对象。 3.实例代码SessionServlet.java 12345678910111213141516171819202122232425262728import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/session&quot;)public class SessionServletextends HttpServlet &#123;@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException &#123;req.setAttribute(&quot;sessionID&quot;, req.getSession().getId()); req.getRequestDispatcher(&quot;session.jsp&quot;).forward(req, resp); &#125;&#125; Session.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;requestScope.sessionID&#125;&lt;/body&gt;&lt;/html&gt; build.gradle1234567891011121314plugins &#123; id &apos;war&apos;&#125;version &apos;0.0.1&apos;repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;javax.servlet&apos;, name: &apos;javax.servlet-api&apos;, version: &apos;4.0.1&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.11&apos;&#125; http-session源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是广义，什么是狭义]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BF%E4%B9%89%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%8B%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[广义：就是不渉及具体概念，只是一个框架，其有确定的抽象概念，但没有确定的形象概念。狭义：就是在系统中设定或区分某一相对狭窄的、片面的、局部的点、面、区域、系统，主要指某一物质系统中具有特殊的、有别于一般的、非普遍的部分。相对广义而言。广义包含狭义，例如：狭义上咱俩都是人，广义上咱俩都是动物。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>广义</tag>
        <tag>狭义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install ShadowSocks]]></title>
    <url>%2F2018%2F02%2F13%2FCentOS%20Install%20ShadowSocks%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829yum install zlib-develyum install gccyum install openssl-develwget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tar.xzxz -d Python-2.7.12.tar.xz &amp; tar xvf Python-2.7.12.tartar xvf Python-2.7.12.tarcd Python-2.7.12./configure --with-zlib=/usr/includemake &amp;&amp; make altinstallcd /usr/binmv python python_bakln -s /usr/local/bin/python2.7 ./pythonvi yumcdwget https://bootstrap.pypa.io/get-pip.pypython get-pip.pyyum install m2cryptocdwget https://download.libsodium.org/libsodium/releases/libsodium-1.0.11.tar.gztar -xvf libsodium-1.0.11.tar.gzcd libsodium-1.0.11./configuremake &amp;&amp; make installecho /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.confldconfigssserver -c config -d startssserver -c config -d stop]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Mysql]]></title>
    <url>%2F2018%2F02%2F13%2FCentOS%20Install%20Mysql%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223241.http://dev.mysql.com/downloads/repo/yum/ 地址下载相对应rpm包2.rpm -ivh mysql57-community-release-el7-8.noarch.rpm (此时/etc/yum.reps.d/下已经有mysql地址源)3.yum makecache4.yum list | grep mysql(查询mysql-server)5.yum install mysql-community-server.x86_64 进行安装6.service mysqld restart7.cat /var/log/mysqld.log | grep password8.vi /etc/my.cnf ([mysqld] 下增加 validate-password=OFF 关闭密码长度等机制)9.systemctl restart mysqld.service (重启服务)10.mysql -uroot -p (登录mysql)11.SET PASSWORD = PASSWORD(&apos;root&apos;); ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER; flush privileges;12.client端用户命令：GRANT ALL ON *.* TO root@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;(GRANT &lt;privileges&gt; ON &lt;what&gt; TO &lt;user&gt; [IDENTIFIED BY &quot;&lt;password&gt;&quot;] [WITH GRANT OPTION];)(打开MYSQL:service mysqld start关闭MYSQL:service mysqld stop)13.firewall-cmd --zone=public --add-port=3306/tcp --permanent (防火墙) systemctl stop firewalld systemctl start firewalld]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Pip Requirements]]></title>
    <url>%2F2018%2F02%2F08%2FPython%20Pip%20Requirements%2F</url>
    <content type="text"><![CDATA[1234//导出requirementspip freeze &gt; requirements.txt//导入requirementspip install -r requirements.txt]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Redis]]></title>
    <url>%2F2018%2F02%2F08%2FCentOS%20Install%20Redis%2F</url>
    <content type="text"><![CDATA[已安装GCCREDIS下载地址12345678wget http://download.redis.io/releases/redis-3.2.3.tar.gztar xzf redis-3.2.3.tar.gzcd redis-3.2.3&lt;make (致命错误：jemalloc/jemalloc.h：没有那个文件或目录)&gt;make MALLOC=libcfirewall-cmd --zone=public --add-port=6379/tcp --permanent systemctl stop firewalld systemctl start firewalld redis.conf 末尾增加bing 0.0.0.012redis-serverredis-cli -h xxx.xxx.xxx.xxx]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql Data Backup]]></title>
    <url>%2F2018%2F02%2F07%2FMysql%20Data%20Backup%2F</url>
    <content type="text"><![CDATA[1.Create sh script file1touch backup.sh 2.Copy this code and paste it into backup.sh script file123456789#bin/shMYSQLDUMP=YOUR_MYSQLDUMP_PATHMYSQL_USERNAME=YOUR_MYSQL_USERNAMEMYSQL_PASSWORD=YOUR_MYSQL_PASSWORDMYSQL_HOST=YOUR_MYSQL_HOSTMYSQL_PORT=YOUR_MYSQL_PORTMYSQL_DB=YOUR_MYSQL_DBSQL_NAME=$&#123;MYSQL_DB&#125;&quot;_&quot;&quot;`date &quot;+%Y%m%d%H%M%S&quot;`&quot;&quot;.sql&quot;$&#123;MYSQLDUMP&#125; -u$&#123;MYSQL_USERNAME&#125; -h$&#123;MYSQL_HOST&#125; -P$&#123;MYSQL_PORT&#125; -p$&#123;MYSQL_PASSWORD&#125; $&#123;MYSQL_DB&#125; &gt; ./$&#123;SQL_NAME&#125; 3.Modify file permissions1chmod 755 ./backup.sh 4. Execute sh script file1./backup.sh]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Nginx]]></title>
    <url>%2F2018%2F02%2F07%2FCentOS%20Install%20Nginx%2F</url>
    <content type="text"><![CDATA[1.INSTALL123451 http://nginx.org/en/linux_packages.html##stable2.cd /etc/yum.repos.d/3.nginx.repo4.yum makecache5.yum install nginx.x86_64 2.USE123start: nginxstop: nginx -s stopreload: nginx -s reload]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
