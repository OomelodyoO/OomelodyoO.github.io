<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows Install ZooKeeper]]></title>
    <url>%2F2018%2F10%2F17%2FWindows%20Install%20ZooKeeper%2F</url>
    <content type="text"><![CDATA[笔者认为只要能在Windows下运行的项目，在MacOS、Linux出现问题的概率会很小，所以此次选择在Windows环境下安装运行zookeeper项目。 1.下载地址ZooKeeper下载地址 2.解压安装使用解压工具对压缩包进行解压 3.配置使用 进入conf文件夹 复制zoo_sample.cfg文件为zoo.cfg 配置参数 参数名 参数值 备注 dataDir F:\zookeeper-3.4.13\data 数据存放位置 dataLogDir F:\zookeeper-3.4.13\log 日志存放位置 clientPort 2181 开启端口号 4.启动Server1zkServer.cmd 5.启动Client1zkCli.cmd 6.Client命令]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（三）JAVA NIO SELECTOR]]></title>
    <url>%2F2018%2F09%2F12%2F%EF%BC%88%E4%B8%89%EF%BC%89JAVA%20NIO%20SELECTOR%2F</url>
    <content type="text"><![CDATA[Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。SelectServer.java123456789101112131415161718192021222324252627282930313233343536373839public class SelectServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); serverSocketChannel.configureBlocking(false); Selector selector = Selector.open(); SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; int select = selector.select(); if (select &gt; 0) &#123; Iterator keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey next = (SelectionKey) keyIterator.next(); keyIterator.remove(); if (next.isAcceptable()) &#123; System.out.println(&quot;isAcceptable&quot;); SocketChannel channel = ((ServerSocketChannel) next.channel()).accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (next.isConnectable()) &#123; System.out.println(&quot;connect&quot;); &#125; else if (next.isReadable()) &#123; System.out.println(&quot;isReadable&quot;); SocketChannel socketChannel = (SocketChannel) next.channel(); ByteBuffer readByteBuffer = ByteBuffer.allocate(100); int read = socketChannel.read(readByteBuffer); System.out.println(new String(readByteBuffer.array(), 0, read)); socketChannel.register(selector, SelectionKey.OP_WRITE); socketChannel.write(readByteBuffer); &#125; else if (next.isWritable()) &#123; System.out.println(&quot;isWritable&quot;); SocketChannel socketChannel = (SocketChannel) next.channel(); socketChannel.register(selector, SelectionKey.OP_READ); &#125; &#125; &#125; &#125; &#125;&#125; NioChannelClient.java12345678910public class NioChannelClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999)); while (true) &#123; Scanner input = new Scanner(System.in); socketChannel.write(ByteBuffer.wrap(input.nextLine().getBytes())); &#125; &#125;&#125; Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）JAVA NIO CHANNEL]]></title>
    <url>%2F2018%2F09%2F11%2F%EF%BC%88%E4%BA%8C%EF%BC%89JAVA%20NIO%20CHANNEL%2F</url>
    <content type="text"><![CDATA[FileChannel 从文件中读写数据。FileChannelTest.java12345678910111213141516171819public class FileChannelTest &#123; public static void main(String[] args) throws IOException &#123; FileChannel inputFileChannel = new FileInputStream(&quot;file.text absolute path&quot;).getChannel(); ByteBuffer readBuffer = ByteBuffer.allocate(100); inputFileChannel.read(readBuffer); readBuffer.flip(); for (int i = 0; i &lt; readBuffer.limit(); i++) &#123; System.out.println((char) readBuffer.get()); &#125; FileChannel outputFileChannel = new FileOutputStream(&quot;file.text absolute path&quot;, true).getChannel(); ByteBuffer writeBuffer = ByteBuffer.wrap(&quot;TOM&quot;.getBytes()); outputFileChannel.write(writeBuffer); inputFileChannel.close(); outputFileChannel.close(); &#125;&#125; DatagramChannel 能通过UDP读写网络中的数据。DatagramChannelServer.java12345678910111213141516public class DatagramChannelServer &#123; public static void main(String[] args) throws IOException &#123; DatagramChannel channel = DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(9999)); ByteBuffer buf = ByteBuffer.allocate(48); while (true) &#123; channel.receive(buf); buf.flip(); for (int i = 0; i &lt; buf.limit(); i++) &#123; System.out.println((char) buf.get()); &#125; buf.clear(); &#125; &#125;&#125; DatagramChannelClient.java12345678public class DatagramChannelClient &#123; public static void main(String[] args) throws IOException &#123; DatagramChannel channel = DatagramChannel.open(); ByteBuffer buf = ByteBuffer.allocate(48); buf = buf.wrap(&quot;AA&quot;.getBytes()); channel.send(buf, new InetSocketAddress(&quot;localhost&quot;, 9999)); &#125;&#125; ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。SocketChannel 能通过TCP读写网络中的数据。NioChannelServer.java123456789101112131415161718public class NioChannelServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); ByteBuffer buf = ByteBuffer.allocate(48); while (true) &#123; SocketChannel channel = serverSocketChannel.accept(); while (true) &#123; channel.read(buf); buf.flip(); for (int i = 0; i &lt; buf.limit(); i++) &#123; System.out.println((char) buf.get()); &#125; buf.clear(); &#125; &#125; &#125;&#125; NioChannelClient.java12345678910public class NioChannelClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999)); while (true) &#123; Scanner input = new Scanner(System.in); socketChannel.write(ByteBuffer.wrap(input.nextLine().getBytes())); &#125; &#125;&#125; Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）JAVA NIO BUFFER]]></title>
    <url>%2F2018%2F09%2F10%2F%EF%BC%88%E4%B8%80%EF%BC%89JAVA%20NIO%20BUFFER%2F</url>
    <content type="text"><![CDATA[1.变量：capacity： 指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。position： 下一次读取或写入的位置。（每次调用get put方法+1）limit：指定还有多少数据需要取出，或者还有多少空间可以放入数据。（每次调用get put方法时候，通过position与limit对比）2.方法：get：position + 1put：position + 1flip：limit = position position = 0 mark = -1clear：limit = capacity position = 0 mark = -1mark： mark = positionreset：position = m;duplicate：浅拷贝（每个缓存区的上界、容量、位置等属性是各自独立的） 3.代码BufferTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class BufferTest &#123; public static void main(String[] args) &#123; IntBuffer buff = IntBuffer.allocate(10); buff.get(); buff.put(1); buff.get(); buff.put(2); buff.get(); buff.put(3); buff.mark(); buff.get(); buff.put(4); buff.get(); buff.put(5); System.out.println(&quot; ========== init ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(); buff.reset(); System.out.println(&quot; ========== mark reset ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(); buff.flip(); System.out.println(&quot; ========== flip ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(buff.get() + &quot;\t&quot;); &#125; System.out.println(); System.out.println(); buff.clear(); System.out.println(&quot; ========== clear ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(buff.get() + &quot;\t&quot;); &#125; System.out.println(); System.out.println(); //重新数据初始化 System.out.println(&quot; ========== duplicate ========== &quot;); buff.clear(); IntBuffer copyIntBuffer = buff.duplicate(); buff.get(); buff.put(2); System.out.println(&quot; ========== buff duplicate ========== &quot;); System.out.println(&quot;capacity:\t&quot; + buff.capacity()); System.out.println(&quot;limit:\t&quot; + buff.limit()); System.out.println(&quot;position:\t&quot; + buff.position()); System.out.println(buff); System.out.println(&quot; ========== copyIntBuffer duplicate ========== &quot;); System.out.println(&quot;capacity:\t&quot; + copyIntBuffer.capacity()); System.out.println(&quot;limit:\t&quot; + copyIntBuffer.limit()); System.out.println(&quot;position:\t&quot; + copyIntBuffer.position()); for (int i = 0; i &lt; buff.limit(); i++) &#123; System.out.print(copyIntBuffer.get() + &quot;\t&quot;); &#125; System.out.println(); &#125;&#125; 4.Console123456789101112131415161718192021222324252627282930313233 ========== init ========== capacity: 10limit: 10position: 10 ========== mark reset ========== capacity: 10limit: 10position: 6 ========== flip ========== capacity: 10limit: 6position: 00 1 0 2 0 3 ========== clear ========== capacity: 10limit: 10position: 00 1 0 2 0 3 0 4 0 5 ========== duplicate ========== ========== buff duplicate ========== capacity: 10limit: 10position: 2java.nio.HeapIntBuffer[pos=2 lim=10 cap=10] ========== copyIntBuffer duplicate ========== capacity: 10limit: 10position: 00 2 0 2 0 3 0 4 0 5 Nio源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nio</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(TOPICS模式)]]></title>
    <url>%2F2018%2F09%2F09%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-TOPICS%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;item.broadcast&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132333435public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_topic_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.broadcast&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.a&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 1234567891011121314151617181920212223242526272829303132333435public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_topic_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.broadcast&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.b&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(ROUTING模式)]]></title>
    <url>%2F2018%2F09%2F08%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-ROUTING%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;insert&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132333435public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_direct_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_direct_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(P/S模式)]]></title>
    <url>%2F2018%2F09%2F07%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-P-S%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718public class Send &#123; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); String message = &quot;message&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 12345678910111213141516171819202122232425262728293031323334public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue_ps_1&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue_ps_2&quot;; public static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket]]></title>
    <url>%2F2018%2F09%2F06%2FJava%20Socket%2F</url>
    <content type="text"><![CDATA[Server.java12345678910111213141516171819202122232425public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(8081); while (true) &#123; Socket socket = serverSocket.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String str = &quot;&quot;; while ((str = bufferedReader.readLine()) != null) &#123; if (str.equals(&quot;1&quot;)) &#123; Thread.sleep(5 * 1000); &#125; System.out.println(str); &#125; &#125; catch (IOException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; Client.java12345678910111213public class Client &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;localhost&quot;, 8081); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in, &quot;UTF-8&quot;)); while (true) &#123; String str = bufferedReader.readLine(); bufferedWriter.write(str); bufferedWriter.write(&quot;\n&quot;); bufferedWriter.flush(); &#125; &#125;&#125; Java Socket源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(WORK模式)]]></title>
    <url>%2F2018%2F09%2F06%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-WORK%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 1234567891011121314151617181920212223242526272829public class Send &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); for (int i = 0; i &lt; 50; i++) &#123; String message = &quot;message:\t&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(message); try &#123; Thread.sleep(i * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; channel.close(); connection.close(); &#125;&#125; Recv.java 1234567891011121314151617181920212223242526272829303132public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.basicQos(1); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; Recv2.java 12345678910111213141516171819202122232425262728293031323334public class Recv2 &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.basicQos(1); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ五种模式(SIMPLE模式)]]></title>
    <url>%2F2018%2F09%2F05%2FRabbitMQ%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F-SIMPLE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Send.java 123456789101112131415161718192021public class Send &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); String message = &quot;message&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); channel.close(); connection.close(); &#125;&#125; Recv.java 12345678910111213141516171819202122232425public class Recv &#123; public static String QUEUE_NAME = &quot;test_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setVirtualHost(&quot;/zhang&quot;); factory.setUsername(&quot;zhang&quot;); factory.setPassword(&quot;zhang&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, false, false, false, null ); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; build.gradle 123456789101112131415plugins &#123; id &apos;java&apos;&#125;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;5.3.0&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; rabbit-mq源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置ssl证书]]></title>
    <url>%2F2018%2F09%2F04%2FNginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1234567891011server &#123; listen 80; listen 443 ssl; server_name localhost; ssl_certificate /SSLPATH/zhang.crt; ssl_certificate_key /SSLPATH/zhang.key; location / &#123; # TOMCAT proxy_pass http://localhost:5566; &#125;&#125; OPENSSL 自签证书]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openssl 自签证书]]></title>
    <url>%2F2018%2F09%2F04%2FOpenssl%20%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1.（.key）文件通常指私钥。 openssl genrsa -des3 -out zhang.key 1024 2.（.csr）文件csr 是Certificate Signing Request的缩写，即证书签名请求，这不是证书，可以简单理解成公钥，生成证书时要把这个提交给权威的证书颁发机构。 openssl req -new -key zhang.key -out zhang.csr 3.（.crt）crt 即 certificate的缩写，即证书。 openssl x509 -req -days 365 -in zhang.csr -signkey zhang.key -out zhang.crt]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https]]></title>
    <url>%2F2018%2F09%2F03%2FHttps%2F</url>
    <content type="text"><![CDATA[1.HTTP 应用层协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 2.SSL/TLS 会话层协议SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。 3.对称加密非对称加密对称加密技术:“加密”和“解密”密钥相同 非对称加密技术“加密”和“解密”密钥不相同 4.TPC/IP 传输层协议这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 HTTPS=HTTP+SSL/TLS]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http Session]]></title>
    <url>%2F2018%2F08%2F31%2FHttp%20Session%2F</url>
    <content type="text"><![CDATA[1.Cookie简介Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。 目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。 持续的 Cookie 则保存在用户的 Cookie 文件中，下一次用户返回时，仍然可以对它进行调用。在 Cookie 文件中保存 Cookie，有些用户担心 Cookie 中的用户信息被一些别有用心的人窃取，而造成一定的损害。其实，网站以外的用户无法跨过网站来获得 Cookie 信息。如果因为这种担心而屏蔽 Cookie，肯定会因此拒绝访问许多站点页面。因为，当今有许多 Web 站点开发人员使用 Cookie 技术，例如 Session 对象的使用就离不开 Cookie 的支持。 2.Session简介Session 是 用于保持状态的基于 Web服务器的方法。Session 允许通过将对象存储在 Web服务器的内存中在整个用户会话过程中保持任何对象。 3.实例代码SessionServlet.java 12345678910111213141516171819202122232425262728import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/session&quot;)public class SessionServletextends HttpServlet &#123;@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException &#123;req.setAttribute(&quot;sessionID&quot;, req.getSession().getId()); req.getRequestDispatcher(&quot;session.jsp&quot;).forward(req, resp); &#125;&#125; Session.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;requestScope.sessionID&#125;&lt;/body&gt;&lt;/html&gt; build.gradle1234567891011121314plugins &#123; id &apos;war&apos;&#125;version &apos;0.0.1&apos;repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: &apos;javax.servlet&apos;, name: &apos;javax.servlet-api&apos;, version: &apos;4.0.1&apos; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.11&apos;&#125; http-session源码地址​github.com]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是广义，什么是狭义]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BF%E4%B9%89%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%8B%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[广义：就是不渉及具体概念，只是一个框架，其有确定的抽象概念，但没有确定的形象概念。狭义：就是在系统中设定或区分某一相对狭窄的、片面的、局部的点、面、区域、系统，主要指某一物质系统中具有特殊的、有别于一般的、非普遍的部分。相对广义而言。广义包含狭义，例如：狭义上咱俩都是人，广义上咱俩都是动物。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>广义</tag>
        <tag>狭义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install ShadowSocks]]></title>
    <url>%2F2018%2F02%2F13%2FCentOS%20Install%20ShadowSocks%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829yum install zlib-develyum install gccyum install openssl-develwget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tar.xzxz -d Python-2.7.12.tar.xz &amp; tar xvf Python-2.7.12.tartar xvf Python-2.7.12.tarcd Python-2.7.12./configure --with-zlib=/usr/includemake &amp;&amp; make altinstallcd /usr/binmv python python_bakln -s /usr/local/bin/python2.7 ./pythonvi yumcdwget https://bootstrap.pypa.io/get-pip.pypython get-pip.pyyum install m2cryptocdwget https://download.libsodium.org/libsodium/releases/libsodium-1.0.11.tar.gztar -xvf libsodium-1.0.11.tar.gzcd libsodium-1.0.11./configuremake &amp;&amp; make installecho /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.confldconfigssserver -c config -d startssserver -c config -d stop]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Mysql]]></title>
    <url>%2F2018%2F02%2F13%2FCentOS%20Install%20Mysql%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223241.http://dev.mysql.com/downloads/repo/yum/ 地址下载相对应rpm包2.rpm -ivh mysql57-community-release-el7-8.noarch.rpm (此时/etc/yum.reps.d/下已经有mysql地址源)3.yum makecache4.yum list | grep mysql(查询mysql-server)5.yum install mysql-community-server.x86_64 进行安装6.service mysqld restart7.cat /var/log/mysqld.log | grep password8.vi /etc/my.cnf ([mysqld] 下增加 validate-password=OFF 关闭密码长度等机制)9.systemctl restart mysqld.service (重启服务)10.mysql -uroot -p (登录mysql)11.SET PASSWORD = PASSWORD(&apos;root&apos;); ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER; flush privileges;12.client端用户命令：GRANT ALL ON *.* TO root@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;(GRANT &lt;privileges&gt; ON &lt;what&gt; TO &lt;user&gt; [IDENTIFIED BY &quot;&lt;password&gt;&quot;] [WITH GRANT OPTION];)(打开MYSQL:service mysqld start关闭MYSQL:service mysqld stop)13.firewall-cmd --zone=public --add-port=3306/tcp --permanent (防火墙) systemctl stop firewalld systemctl start firewalld]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Pip Requirements]]></title>
    <url>%2F2018%2F02%2F08%2FPython%20Pip%20Requirements%2F</url>
    <content type="text"><![CDATA[1234//导出requirementspip freeze &gt; requirements.txt//导入requirementspip install -r requirements.txt]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Redis]]></title>
    <url>%2F2018%2F02%2F08%2FCentOS%20Install%20Redis%2F</url>
    <content type="text"><![CDATA[已安装GCCREDIS下载地址12345678wget http://download.redis.io/releases/redis-3.2.3.tar.gztar xzf redis-3.2.3.tar.gzcd redis-3.2.3&lt;make (致命错误：jemalloc/jemalloc.h：没有那个文件或目录)&gt;make MALLOC=libcfirewall-cmd --zone=public --add-port=6379/tcp --permanent systemctl stop firewalld systemctl start firewalld redis.conf 末尾增加bing 0.0.0.012redis-serverredis-cli -h xxx.xxx.xxx.xxx]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql Data Backup]]></title>
    <url>%2F2018%2F02%2F07%2FMysql%20Data%20Backup%2F</url>
    <content type="text"><![CDATA[1.Create sh script file1touch backup.sh 2.Copy this code and paste it into backup.sh script file123456789#bin/shMYSQLDUMP=YOUR_MYSQLDUMP_PATHMYSQL_USERNAME=YOUR_MYSQL_USERNAMEMYSQL_PASSWORD=YOUR_MYSQL_PASSWORDMYSQL_HOST=YOUR_MYSQL_HOSTMYSQL_PORT=YOUR_MYSQL_PORTMYSQL_DB=YOUR_MYSQL_DBSQL_NAME=$&#123;MYSQL_DB&#125;&quot;_&quot;&quot;`date &quot;+%Y%m%d%H%M%S&quot;`&quot;&quot;.sql&quot;$&#123;MYSQLDUMP&#125; -u$&#123;MYSQL_USERNAME&#125; -h$&#123;MYSQL_HOST&#125; -P$&#123;MYSQL_PORT&#125; -p$&#123;MYSQL_PASSWORD&#125; $&#123;MYSQL_DB&#125; &gt; ./$&#123;SQL_NAME&#125; 3.Modify file permissions1chmod 755 ./backup.sh 4. Execute sh script file1./backup.sh]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Nginx]]></title>
    <url>%2F2018%2F02%2F07%2FCentOS%20Install%20Nginx%2F</url>
    <content type="text"><![CDATA[1.INSTALL123451 http://nginx.org/en/linux_packages.html##stable2.cd /etc/yum.repos.d/3.nginx.repo4.yum makecache5.yum install nginx.x86_64 2.USE123start: nginxstop: nginx -s stopreload: nginx -s reload]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
